类与继承
	1.Kotlin默认创建的类编译后时public final
	2.Kotlin中所有类的超类是Any类
		Any类的三个方法：equals(),hashCode(),toString()
	3.继承：
		父类必须使用open修饰
		子类继承：:Father
		子类存在主构造函数，而父类必须用子类主构造函数的参数就地初始化
		若派生类没有主构造函数，在每个次构造函数必须使用super关键字初始化其基类型，或调用其他次构造函数
	4.方法覆盖
		被子类覆盖的方法在父类中需要声明为open，同时子类覆写的方法需要声明为override，否则错误
		使用final修饰的方法不可被覆盖
		Kotlin中只有方法覆盖，没有方法重载(同一类中不能出现同名方法)
	5.属性覆盖
		同样是被覆盖(父类)的属性修饰为open，覆盖(子类)的属性修饰为override
		可以用一个var属性(子类)覆盖一个val属性(父类)，在父类val属性的get()方法额外声明一个方法set()，反之不行，不能随意删除
	6.初始化顺序
		构造子类实例前需要完成父类的初始化
		顺序与Java相同：属性直接赋值和初始化块优先级相同，谁在前用谁，然后是构造方法
		设计基类时避免在构造函数、属性初始化器、init块中使用open成员(当基类构造函数执行时，派生类中声明和覆盖的属性都还没有初始化，会产生调用错误，不知道调用的是父类本身的还是子类复写的)
	7.super
		子类调用父类方法：super.父类方法
		内部类调用外部类方法：super@外部类名.外部类方法
		子类调用不同父类/接口的相同方法：super<特定父类/接口名>.父类方法
	8.覆盖原则
		如果子类继承了多个父类，而不同父类中存在相同的成员(方法/属性)，则当前子类必须覆盖该成员，消除歧义
	9.抽象类
		abstract将类或成员声明为抽象，在本类中可不实现，可以使用抽象成员覆盖非抽象的开放成员

类的构造方法
	1.Kotlin中构造方法分为两种
		主构造方法：单独使用的话简化开发,自动生成属性，getter/setter，构造方法
		次构造方法：更能体现出构造方法的重载性
		主构造方法与次构造方法搭配使用：
			由于主构造方法和init{}初始化块一同使用，因此在每个次构造方法声明时必须使用 :this()先调用主构造方法
			即使主构造方法不存在，系统也会默认生成一个无参的
	2.构造方法与继承的结合
		如果子类存在主构造方法，则父类必须存在用子类主构造方法的参数就地初始化(在子类主构造方法后:父类主构造方法)，一旦子类存在了主构造方法，子类的其他次构造方法就需要使用this调用子类的主构造方法
		
	3.父类标准：
		父类存在次构造函数，次构造函数和主构造函数都可以作为标准
		父类不存在次构造函数，主构造函数就是标准
		父类会默认存在无参主构造函数
	4.子类标准
		在子类声明时调用父类的主构造方法+次构造使用this调用子类的主构造方法
		在次构造方法中使用super调用对应的主构造方法(必须存在次构造方法,调用无参构造可以省略super)
	5.Kotlin中不存在new关键字，直接调用构造方法即可

属性与字段
	1.属性的性质
		var可变：存在getter和setter
	  	val不可变：只存在getter
	  	*无论是var还是val都需要赋初值(直接赋值/构造方法/初始化块中赋值)——所有非抽象属性都强制要求初始化
	*.getter和setter的使用
		Kotlin中不允许直接操作类属性(与Java不同，Java如果属性是public就可以直接使用)
		在使用对象.属性或在构造方法中对该属性赋值，Kotlin都会调用该属性的getter或setter方法
	*3.自定义getter和setter
		幕后字段field：在getter/setter使用当前属性的幕后字段field访问当前属性
		自定义getter：get():属性类型{}/get()=函数语句
			不能在属性的getter中再次调用该属性(又会调用该属性的getter方法)，这就会导致无限迭代。
			eg:return field->返回当前属性
		自定义setter：set(value)
			value是一个与属性类型相同的参数
			eg:field=value->当前属性值赋值为value
	4.编译期常量const
		const val(只能是val表示常量)，不存在getter，setter
		位于顶层(不属于任何类，属于文件——类的外部)或是object声明或companion object的一个成员
		以String或原生类型值初始化
		PS:val并不能表示编译器常量，因为val存在getter方法，每次调用val属性时都会调用getter，要是在getter中修改val的值，就会改变val的值
	5.延迟初始化属性与变量
		使用lateinit修饰，属性不需要再(定义时，init块，构造方法)中初始化，可以在其他方法中初始化
		原始类型不能使用lateinit修饰

接口：
	类似于Java8后的接口
	1.方法
		接口中的方法会被其实现类实现，且不需要使用open修饰
		Kotlin接口中可以包含方法(默认是抽象的)的实现
	2.属性
		可以有属性但必须声明为抽象(默认就是)或提供访问器实现
		val prop:Int->默认就是抽象的
		val property:String
			get() = "foo" ->提供访问器，接口中的属性没有幕后字段，因此接口中的访问器不能引用幕后字段
	3.同继承类与实现多个接口相同，若实现多个接口，则也需要在当前类覆盖这些接口的同名抽象方法(编译器不知如何抉择)
	4.抽象类与接口的区别
		抽象类，继承，是不是
		接口，实现，有没有

可见性修饰符
	Kotlin中默认修饰符是public(不写)，没有default了
	1.分类
		private：类内部
		*protected：类内部+子类(与Java不同)
		internal：同一模块中(模块是便衣在一起的一套Kotlin文件)
	2.注意事项
		外部类不能访问内部类的private成员

扩展
	扩展一个类的新功能而无需继承该类或使用设计模式
		扩展函数中的this就指代被扩展类的对象
	扩展是静态解析，并没有在类中真正的插入函数，只是可以使用"."来调用扩展函数
		扩展实际调用的就是声明时的类型，而并非运行时的类型
	若扩展函数与类中真实存在的函数重名，则优先调用真实函数
		扩展函数也可以和真实函数实现方法重载






































