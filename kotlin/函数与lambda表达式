函数：
	1.函数定义：
		fun 函数名(参数1:数据类型，参数2:数据类型...): 返回值类型 {
			// 函数逻辑
			return xx;
		}
	2.返回值：
		函数必须显示指定返回值，除非是Unit类型
		函数没有返回值时：返回Unit 类型或省略不写
	3.函数参数：
		存在默认参数：
			如果默认参数在非默认参数之后，直接传入非默认参数即可
			如果默认参数在非默认参数之前，则必须在传入时声明非默认参数的值（系统根本无法判断当前传入的值时默认参数的替代值还是非默认参数的值）
		命名参数：
			若方法中的部分形参存在默认值，而有无默认值的形参顺序不定，则可以使用命名参数的形式，在调用该方法时对非默认参数进行实参传递，也可对默认参数进行覆盖
			需要注意：在调用方法时一旦使用了命名参数，该参数后面的所有参数都必须使用命名参数
	4.单表达式函数：
		直接在函数声明后加 =xxx
		若返回的类型不确定，则在函数声明按最后不写返回值，直接写 =xxx
	5.可变参数：
		定义为varargs类型（eg：varargs ts: Int)
		一般可变参数需要放在所有参数的最后，如果没有，可变参数之后的参数需要使用命名参数
	

函数作用域
	1.局部函数：
		函数在另一个函数内部：可以访问外部函数的局部变量
	2.泛型函数：
		fun <T> singletonList(item:T):List<T>{...}
	3.尾递归函数：
		将一个递归函数使用tailrec修饰，提高递归的效率
		tailrec fun FieldName():Type{...}

lambda表达式
	**0.前提：无论是匿名函数还是lambda表达式，要么被赋值给某个值，要么作为其他函数的参数
	 	   也就是说：匿名函数/lambda表达式不能独立存在
	*1.lambda本质:lambda表达式实际上就是匿名函数的简写方式
	2.匿名函数：就是没有名字的函数，因此独立存在毫无意义，var ab = fun(x:Int,y:Int):Int{return x+y}
	3.lambda写法：var ab = {参数1:Type1,参数2:Type2...->{ReturnType/最后一个表达式的值(不能写return)}}
	4.单个参数的隐式名称
		若函数类型只有一个参数，则使用it代替即可(不需要使用(it:Int)->Boolean)
	5.lambda表达式的返回值：不能使用return，返回的是最后一个表达式的值
	6.匿名函数与lambda的区别
		匿名函数的return：从匿名函数返回
		lambda的return：由于lambda不存在return，因此会从包含该lambda的函数返回
	7.闭包
		在外部作用域中声明的变量，在lambda表达式中可以修改闭包中捕获的变量
	*****8.lambda代替匿名方法/匿名内部类的场景：
		代替匿名方法：高阶函数的参数是一个函数类参数
		代替匿名内部类：Kotlin专门给"Java"提供的一个语法糖->接口必须是Java的接口，并且符合SAM，才能使用lambda，将lambda表达式转换为对应的匿名类的实例
			函数的参数是一个类/接口，需要传入当前类的实例或接口的实现对象，只有符合SAM，才能使用lambda，否则只能使用标准的匿名内部类
			由于类型是可以推断出来的(SAM就那一个方法)，该方法名都可以省略
				**相当于：直接在{}中使用lambda的格式实现接口唯一的那个方法即可(eg:a:Int,b:Double->xxx)
						如果SAM方法只有一个参数，lambda表达式连参数都不需要写，直接实现该方法就可以了(实现中it就表示当前的参数)
		需要注意对于Kotlin的接口，无论符不符合SAM，都不能使用lambda(Kotlin中直接整个接口名意思是调用该Interface的构造函数，但Interface又没有构造函数，因此报错)
	****9.总结：由于Java没有函数类型，因此采用lambda构造一个匿名对象，变相的绕过语言层面的限制(这是个语法糖，记住就行！！)
		       对于Kotlin来讲，函数本身就是一等公民，传入的就是一个函数类型的变量就行

高阶函数
	0.Kotlin中真正做到了万物皆对象，即便是一个函数也相当于是一个对象，因此也可以作为参数传来传去
	1.高阶函数：将函数用作参数或返回值的函数
	2.高阶函数的定义(使用R,T泛型)
		高阶函数形参是一个函数类型：(acc: R,nextElement: T)->R，当前接受的函数是形参是R，T类型的参数且返回值为R类型的函数
		作为高阶函数的形参，实际上就是采用lambda表达式进行函数的定义(参数列表->返回值)
	3.高阶函数的调用
		只要是符合高阶函数该参数定义的函数类型的函数，就可以作为形参传入高阶函数中
		调用时的实参就是标准的lambda表达式调用格式，相当于是采用lambda表达式进行函数的实现(由于类型已经被定义，因此不需要传入类型，系统会自动解析)
		也可以使用函数引用(Java8的新特性)<Int::times>
	4.高阶函数的函数参数传递
		声明
			要么采用函数类型声明
			要么采用lambda表达式的声明函数形式(在函数类型声明的基础上添加变量名称)
			匿名函数声明形式
		调用
			传入一个函数即可，具体形式可以是有名，匿名，lambda
			或使用函数调用
	5.传递末尾的lambda表达式(拖尾lambda)
		如果高阶函数的最后一个参数是一个函数，调用时传入的lambda可以放在圆括号外实现：函数名(前面参数列表){//lambda}
		如果只有一个函数参数，连()都可以省略：函数名{//lambda}
	6.



函数类型
	1.函数类型也是一种数据类型：(参数1Type，参数2Type...)->返回值Type
	2.若一个变量被声明为了函数类型，该变量就可以接收一个函数(可以有名，匿名，lambda)
	3.因此函数类型同样也可以作为高阶函数的参数
	4.带有接收者的函数字面值

高阶函数与lambda表达式的结合使用
	相当于高阶函数使用了一个函数参数，要么在高阶函数中对该函数参数的结果进行某些处理，要么在高阶函数中需要调用该函数进行操作
	与普通的函数声明，调用一毛一样
		声明高阶函数时：参数列表，方法体，返回值已经写好(参数遇到函数的情况，使用函数类型/lambda表示，只不过lambda表示会指定形式参数名<没什么卵用，形参实参名也可以不同，可能只是为了增加可读性>)
		调用高阶函数时需要传入参数，只不过此时若碰到函数参数，可以使用lambda表达式将一个匿名函数传入(或者也可以直接传入其他已定义好的有名函数)
























